//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	ttemplate "text/template"

	"gopkg.in/yaml.v2"
)

type field struct {
	Accessor        string `yaml:"accessor"`
	Type            string `yaml:"typename"`
	Cast            string `yaml:"typecast"`
	Stringname      string `yaml:"stringname"`
	AccessorComment string `yaml:"getcomment"`
	MutatorComment  string `yaml:"setcomment"`
}

type blueprint struct {
	Name        string  `yaml:"name"`
	Lattice     string  `yaml:"lattice"`
	Description string  `yaml:"description"`
	Informal    string  `yaml:"informal"`
	Fields      []field `yaml:"fields"`
}

func (f field) Typecast() string {
	if f.Cast == "Element" {
		return ""
	}
	return "." + f.Cast + "()"
}

func formatComment(str string) string {
	return strings.Join(strings.Split(strings.TrimSpace(str), "\n"), "\n// ")
}

func main() {
	startfilename := strings.TrimSuffix(os.Getenv("GOFILE"), ".go")

	productYaml, err := os.ReadFile(filepath.Join(filepath.Dir(startfilename), os.Args[1]+".yaml"))
	if err != nil {
		log.Fatal(err)
	}

	var prod blueprint
	if err = yaml.Unmarshal(productYaml, &prod); err != nil {
		log.Fatal(err)
	}

	prod.Description = formatComment(prod.Description)

	// Format comment strings.
	for f, field := range prod.Fields {
		field.AccessorComment = formatComment(field.AccessorComment)
		field.MutatorComment = formatComment(field.MutatorComment)

		prod.Fields[f] = field
	}

	templateB, err := os.ReadFile("product-wrapper-template.go")
	if err != nil {
		log.Fatal(err)
	}

	template := string(templateB)

	// Discard the first two lines
	template = strings.SplitN(template, "\n", 3)[2]

	// Add typesafe accessor and update methods
	templ := ttemplate.Must(ttemplate.New("").Parse(`
{{ range $index, $field := . }}
// {{$field.Accessor}} {{ $field.AccessorComment }}
func (w WrappedProductElement) {{ $field.Accessor }}() {{ $field.Type }} {
	return w.product.Get({{ $index }}){{ $field.Typecast }}
}

// Update{{ $field.Accessor }} {{ $field.MutatorComment }}
func (w WrappedProductElement) Update{{ $field.Accessor }}(value {{ $field.Type }}) WrappedProductElement {
	w.product = w.product.Update({{ $index }}, value)
	return w
}
{{ end }}`))

	var buf bytes.Buffer
	err = templ.Execute(&buf, prod.Fields)
	if err != nil {
		log.Fatalln(err)
	}

	// Add a safety check function
	templ = ttemplate.Must(ttemplate.New("").Parse(`
func _checkWrappedProductElement(el WrappedProductElement) {
	if len(*el.product.prod) != {{ len . }} {
		panic("Product length mismatch. Expected {{ len . }}.")
	}

	{{ range . }}el.{{ .Accessor }}()
	{{ end }}}`))

	err = templ.Execute(&buf, prod.Fields)
	if err != nil {
		log.Fatalln(err)
	}

	template = template + buf.String()

	// Generate STRING_ENTRIES
	entries := []string{}
	for _, field := range prod.Fields {
		entries = append(entries, fmt.Sprintf("\t\t{\"%s\", w.%s()},", field.Stringname, field.Accessor))
	}

	for _, repl := range []struct{ src, dest string }{
		{`WrappedProductLattice`, prod.Lattice},
		{`WrappedProductDescription`, prod.Description},
		{`InformalProductElement`, prod.Informal},
		{`WrappedProductElement`, prod.Name},
		{`(?m)^.*STRING_ENTRIES\,`, strings.Join(entries, "\n")},
	} {
		re := regexp.MustCompile(repl.src)
		template = re.ReplaceAllString(template, repl.dest)

	}

	template = fmt.Sprintf("// Code generated by generate-product.go for %s. DO NOT EDIT.\n\n%s", prod.Name, template)

	finalName := startfilename + "_gen.go"
	os.WriteFile(finalName, []byte(template), 0666)

	cmd := exec.Command("goimports", "-w", finalName)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Successfully generated", finalName)
}
